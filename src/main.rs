use std::{
    fs::read_to_string,
    path::{Path, PathBuf},
};

use pest::Parser;
use regex::Regex;

use crate::parser::{SvgElement, SvgParser};
use crate::writer::{ConsoleWriter, FileWriter, Writer};

mod parser;
mod writer;

fn main() -> anyhow::Result<()> {
    let cmd = create_command();

    let matches = cmd.get_matches();

    match matches.subcommand() {
        Some(("dry-run", matches)) => {
            let path = matches.get_one::<std::path::PathBuf>("PATH");
            handle_file(
                path.expect("should at least have one path"),
                ConsoleWriter {},
            )?;
            println!("{:#?}", path);
        }
        Some(("generate", matches)) => {
            let path = matches.get_one::<std::path::PathBuf>("PATH");
            handle_file(path.expect("should at least have one path"), FileWriter {})?;
            println!("{:#?}", path);
        }
        Some(("groups", matches)) => {
            let path = matches.get_one::<std::path::PathBuf>("PATH");
            structure(path.expect("should at least have one path"))?;
        }
        _ => unreachable!("clap should ensure we don't get here"),
    };

    Ok(())
}

fn print_structure(svg: SvgElement) {
    println!("SVG");
    println!("├── {}", svg.tag);
    for (key, value) in svg.attributes {
        println!("│   ├── {}: {}", key, value);
    }
    for node in svg.nodes {
        print_node(node, 1);
    }
}

fn print_node(node: SvgElement, level: usize) {
    let mut prefix = String::new();
    for _ in 0..level {
        prefix.push_str("│   ");
    }
    if node.tag == "g" && node.attributes.contains_key("id") {
        println!(
            "{}├── group: {}",
            prefix,
            node.attributes.get("id").unwrap()
        );
    } else {
        println!("{}├── {}", prefix, node.tag);
    }
    for (key, value) in node.attributes {
        if key == "id" {
            continue;
        }
        println!("{}│   ├── {}: {}", prefix, key, value);
    }
    for node in node.nodes {
        print_node(node, level + 1);
    }
}

fn structure<P: AsRef<Path>>(path: P) -> anyhow::Result<()> {
    let unparsed_file = read_to_string(&path)
        .expect("cannot read file")
        .replace("\n", "")
        .replace("    ", "");
    let mut parsed = SvgParser::parse(parser::Rule::root, &unparsed_file).unwrap();
    let document = parsed.next().unwrap();
    let svg = SvgElement::try_from(document).unwrap();

    print_structure(svg);

    Ok(())
}

/// Handle inputed files
fn handle_file<P: AsRef<Path>>(path: P, writer: impl Writer) -> anyhow::Result<()> {
    let mut unparsed_file = read_to_string(&path)
        .expect("cannot read file")
        .replace("\n", "");
    //.replace("    ", "");

    let re = Regex::new(r"\s+").unwrap();
    unparsed_file = re.replace_all(&unparsed_file, " ").to_string();
    let mut parsed = SvgParser::parse(parser::Rule::root, &unparsed_file).unwrap();
    let document = parsed.next().unwrap();
    let svg = SvgElement::try_from(document).unwrap();

    let name = handle_file_name(path.as_ref().as_os_str().to_str().unwrap());
    let mut contents: String = String::from("// Generated by SVGenerator");
    contents.push_str(svg.to_string().as_str());
    let _ = writer.write(&name, contents.as_str())?;
    Ok(())
}

fn handle_file_name(name: &str) -> String {
    let name = name.to_string();
    name.replace(".svg", ".cairo")
}

/// Create command instance to parse out inputed files
///
fn create_command() -> clap::Command {
    clap::Command::new("svgenerator")
        .bin_name("svgenerator")
        .subcommand_required(true)
        .subcommand(
            clap::Command::new("dry-run")
                .about("Check the expected output")
                .arg(
                    clap::arg!(<PATH> ... "The file to parse out.")
                        .value_parser(clap::value_parser!(PathBuf)),
                )
                .arg_required_else_help(true),
        )
        .subcommand(
            clap::Command::new("generate")
                .about("Generate the files output")
                .arg(
                    clap::arg!(<PATH> ... "The file to parse out.")
                        .value_parser(clap::value_parser!(PathBuf)),
                )
                .arg_required_else_help(true),
        )
        .subcommand(
            clap::Command::new("groups")
                .about("Generate the SVG group structure")
                .arg(
                    clap::arg!(<PATH> ... "The file to parse out.")
                        .value_parser(clap::value_parser!(PathBuf)),
                )
                .arg_required_else_help(true),
        )
}
